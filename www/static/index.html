<!DOCTYPE html>
<html>
<title>r/place analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="style.css">

<script src="https://unpkg.com/d3-regression@1.3.10/dist/d3-regression.min.js"></script>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="keypoints.js"></script>
<script src="anchornav.js"></script>


<link href='https://fonts.googleapis.com/css?family=IBM Plex Sans Condensed' rel='stylesheet'>


<style type="text/css">

</style>

<body>

  <h1 class="center">r/place Analysis</h1>

  <div class="container col">

    <div class="center">
      <p>
        Starting on April 1, 2022, Reddit users collaboratively edited a 1000 pixel x 1000 pixel canvas on the r/place
        subreddit. Each user was able to change the color of a single pixel with replacement from a limited palette with
        5 minute pauses in between changes. The canvas doubled in size two times, eventually ending up 2000 pixel x 2000
        pixel large. r/place had appeared before in 2017, but the volume of contributers in the 2022 r/place far
        outshined its predecessor. Various groups, such as r/turkey, r/france, twitch audiences, etc. banded together to
        leave their mark on the canvas.
      </p>
      <div>
        <svg id="expo1" width="900" height="300"></svg>
      </div>

      <div class="smallmults">
        <svg id="expo2" width="440" height="300"></svg>
        <svg id="expo3" width="440" height="300"></svg>
      </div>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo
        viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus
        ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet
        non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at
        consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas
        fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed
        cras.</p>
      <div class="smallmults">
        <svg id="expo4" width="440" height="300"></svg>
        <svg id="expo5" width="440" height="300"></svg>
      </div>

    </div>

  </div>


  <div class="caseandnav">
    <nav class="nav">
      <h2>Highlights</h2>
      <ol>
        <li><a href="#canada">Canadian Flag</a></li>
        <li><a href="#france">France</a></li>
        <li><a href="#dutch">Dutch Paintings</a></li>
        <li><a href="#creeper">Creeper Animation</a></li>
        <li><a href="#void">The Void</a></li>
      </ol>
    </nav>

    <div id="keypoints" class="center">

      <!-- gets populated with divs for each case -->
      <!-- ex: -->
      <!-- <div>
          <h3></h3>
          <p></p>
          <svg></svg>
          <p></p>
        </div> -->


    </div>

  </div>


  <script>
    const color_17 = '#9932a8'
    const color_22 = '#439abf'

    async function tileschart(data, svgId, color, category) {

      const svg = d3.select("#" + svgId);
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat('')
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      // Credit: Legend based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 5 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 20)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category);

      loessRegression = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg = loessRegression(data)

      let lineGen = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      let line = chart.append("path")
        .datum(data_reg)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color)
        .attr("stroke-width", 1)
        .attr("d", lineGen);

      // Credit: Tooltip based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let tooltip = chart.append("div")
        .attr('id', svgId + 'tooltip')
        .style('position', 'absolute')
        .style("background-color", "#D3D3D3")
        .style('padding', 6)
        .style('display', 'none')

      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", "mouse-over-effects");

      mouseG.append("path")
        .attr("class", "mouse-line")
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", "mouse-per-line");

      mousePerLine.append("circle")
        .attr("r", 4)
        .style("stroke", color)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select(".mouse-line")
            .style("opacity", "0");
          d3.selectAll(".mouse-per-line circle")
            .style("opacity", "0");
          d3.selectAll(".mouse-per-line text")
            .style("opacity", "0");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'none')

        })
        .on('mouseover', function () {
          d3.select(".mouse-line")
            .style("opacity", "1");
          d3.selectAll(".mouse-per-line circle")
            .style("opacity", "1");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'block')
        })
        .on('mousemove', function () {
          var mouse = d3.mouse(this);

          // d3.selectAll(".mouse-per-line")
          //   .attr("transform", function (d, i) {

          //     d3.select(".mouse-line")
          //       .attr("d", function () {
          //         let data = "M" + xScale(d.values[idx].date) + "," + (height);
          //         data += " " + xScale(d.values[idx].date) + "," + 0;
          //         return data;
          //       });
          //     return "translate(" + xScale(d.values[idx].date) + "," + yScale(d.values[idx].premium) + ")";

          //   });

          // updateTooltipContent(mouse, res_nested)

        });

    }

    async function tileschartmultiple(data1, data2, svgId, color1, color2, category1, category2) {

      const svg = d3.select("#" + svgId);
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const data = d3.merge([data1, data2])

      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });;
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 0 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 40)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color1);

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 20)
        .attr("r", radius)
        .style("fill", color2);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category1);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", 20 + radius / 2)
        .style("font-size", 12)
        .text(category2);

      loessRegression1 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg1 = loessRegression1(data1)

      let lineGenr1 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg1)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color1)
        .attr("stroke-width", 2)
        .attr("d", lineGenr1);

      loessRegression2 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg2 = loessRegression2(data2)

      let lineGenr2 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen2 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg2)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color2)
        .attr("stroke-width", 2)
        .attr("d", lineGenr2);

    }

    async function histogram(data, svgId, color) {
      data.forEach(d => {
        d["users"] = parseInt(d["posts"]);
        d['posts'] = parseInt(d[""]);
        console.log(d["posts"])
      })
      let bin_num = 50
      data = data.filter(d => d['posts'] <= bin_num);
      console.log(data)

      const svg = d3.select("#" + svgId);
      const margin = { top: 10, right: 10, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const postExtent = d3.extent(data, d => d['posts']);
      const postScale = d3.scaleBand()
      .domain(data.map(d=>d['posts']))
      .range([0, width])
      .padding(0.2);
      

      const userExtent = d3.extent(data, d => d['users']);
      console.log(userExtent)
      const userScale = d3.scaleLinear().domain(userExtent).range([height, 0]);

      let leftAxis = d3.axisLeft(userScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(userScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(postScale)
      let bottomGridlines = d3.axisBottom(postScale).ticks(bin_num)
        .tickSize(-height - 10)
        .tickFormat("")

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Users");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("# of Posts");


  // Bars
      svg.selectAll("rect")
        .data(data)
        .enter()
        .append("rect")
        .attr("users", d=> d["users"])
        .attr("num_posts", d=> d["posts"])
        .attr("x", d=> postScale(d["posts"]) ) 
        .attr("y", d=> userScale(d["users"]) ) 
        .attr("width", postScale.bandwidth())
        .attr("height", d => height - userScale(d['users']) )
        .style("fill", color);
    }


    /**
     *  Data should be given in a 2d array with the value being the
     *  number of changes for for a pixel at (row, col).
     *  DivId should be the id for the div that the heatmap will be
     *  nested inside.
     *  PixelSize should be the size of each pixel in the heatmap.
     * 
     *  Credit: Adapted from https://jeffrz.github.io/info4310-sp2022/notes/22.04.25.notes.htm
     **/
    async function heatmap(data, divId, pixelSize) {

      let width = data[0].length * pixelSize;
      let height = data.length * pixelSize;

      let data1D = []
      data.forEach((row, i) => {
        row.forEach((val, j) => {
          data1D.push({
            'x': j,
            'y': i % width,
            'value': val
          })
        })
      })

      calc1D = data.flat()
      let min = d3.min(calc1D)
      let max = d3.max(calc1D)

      let heatmap_color = d3.scaleSequential()
        .interpolator(d3.interpolateViridis)
        .domain([min, max])

      let canvas = d3.select("#" + divId)
        .append('canvas')
        .attr('width', width)
        .attr('height', height)
        .attr('id', divId + 'canvas')

      let context = canvas.node().getContext('2d');

      // create a parent for all the elements
      let changes = document.createElement('changes');
      let heatmap = d3.select(changes);

      //bind the data to canvas elements
      heatmap.selectAll('changes.rect')
        .data(data1D)
        .enter()
        .append('changes')
        .attr('class', 'rect')
        .attr("height", pixelSize)
        .attr("width", pixelSize)
        .attr("x", cell => { return cell.x * pixelSize })
        .attr("y", cell => { return cell.y * pixelSize })
        .attr("fillStyle", cell => {
          let color = d3.color(heatmap_color(cell.value))
          color.opacity = 0.5;
          return color + "";
        });

      context.clearRect(0, 0, width, height);

      heatmap.selectAll('changes.rect')
        .each(function (d, i) {
          let node = d3.select(this);
          context.beginPath();
          context.rect(node.attr('x'),
            node.attr('y'),
            node.attr('width'),
            node.attr('height'));
          context.fillStyle = node.attr('fillStyle');
          context.fill();
        });
    }

    /**
     * When adding a key point, make sure to also call:
     *      heatmap(<data>, <heatmapname>, <pixelSize>);
     * in the requestData() function. 
     * <heatmapname> should match the heatmapname for the new key point.
     **/
    addKeypoint(
      title = "Canadian Flag",
      divname = "canada",
      heatmapname = "canadianflag",
      paragraph1 = "In a comical turn of events, what began as a collaborative effort between those at r/Canada to create a depiction of the Canadian flag turned into a failed attempt at drawing a maple leaf that spanned nearly the entirety of r/place\’\s existence. Canada\’\s flag quickly became the target of memes as their leaf was never quite in shape. This led to constant vandalism of the flag. At one point, the flag was changed to yellow and the leaf changed to a banana. Canada managed to gain a little progress on their leaf, however the canvas ended before it could be fully completed.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "French Flag",
      divname = "france",
      heatmapname = "frenchflag",
      paragraph1 = "With what originally began as a large French flag in the lower left hand corner, this collaborative effort by the folks behind r/France eventually evolved into beautiful recreations of the Eiffel Tower, Arc de Triomphe, the Louvre, and even Remy from Ratatouille! The Void tried its best to take over but r/France prevailed and eventually held one of the largest cohesive squares on the map.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "Dutch Paintings",
      divname = "dutch",
      heatmapname = "dutchpaintings",
      paragraph1 = "An incredibly accurate recreation of very famous dutch paintings such as Vermeer\’\s \“\Girl with a Pearl Earring\”\, Rembrandt’\s\ \“\The Night Watch\”\, and a famous painting depicting Michael de Ruyter\’\s naval battle, a source of immense pride for the Netherlands. In addition, the users at r/placeNL decided to help out those at r/canada in producing a Canadian flag for them, an interesting reflection of the relationship between Canada and Netherlands stemming from WW2 where Canadian troops were among the first to liberate many occupied Dutch cities.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "Creeper Animation",
      divname = "creeper",
      heatmapname = "creeperanimation",
      paragraph1 = "This is where the Minecraft loading screen animation took place, which was one of the most upvoted posts on r/place. The animation was created by streamers NymN and Zoil.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "The Void",
      divname = "void",
      heatmapname = "voidmap",
      paragraph1 = "\“\The Void\”\ refers to several distorted images and art present nearly at all times of r/place\’\s existence, especially as many griefers would try their best to destroy art around the canvas. In addition, The Void, in its final moments, was a large area of black pixels consuming art wherever it spread. After the main void was destroyed by The First Hand, it moved up TotalBiscuit\’\s hair and reformed right before the canvas ended. Created by The Swarm.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )



    function csvToArray(csv) {
      rows = csv.split("\n");
      return rows.map(function (row) {
        return row.split(",");
      });
    };

    const requestData = async () => {

      let tileData2017 = await d3.csv("data/2017_time_data.csv");
      tileData2017.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      let tileData2022 = await d3.csv("data/2022_time_data.csv");
      tileData2022.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      tileschartmultiple(tileData2017, tileData2022, 'expo1', color_17, color_22, 2017, 2018);
      tileschart(tileData2017, 'expo2', color_17, 2017);
      tileschart(tileData2022, 'expo3', color_22, 2022);

      // TODO: replace testData with real data
      // const canadianflagData = await d3.text("../data/test1.csv");
      // heatmap(csvToArray(canadianflagData), 'canadianflag', 10);

      // const frenchflagData = await d3.text("../data/test1.csv");
      // heatmap(csvToArray(frenchflagData), 'frenchflag', 1);

      // const dutchData = await d3.text("../data/test1.csv");
      // heatmap(csvToArray(dutchData), 'dutchpaintings', 1);

      // const creeperData = await d3.text("../data/test2.csv");
      // heatmap(csvToArray(creeperData), 'creeperanimation', 1);

      // const voidData = await d3.text("../data/test2.csv");
      // heatmap(csvToArray(voidData), 'voidmap', 10);


      let userData2017 = await d3.csv("data/2017_user_data.csv");
      histogram(userData2017, 'expo4', color_17);

      let userData2022 = await d3.csv("data/2022_user_data.csv");
      histogram(userData2022, 'expo5', color_22);
    }


    // for the dynamic styling on the anchor nav sidebar--
    // this must stay at the bottom of the script to work
    const sections = document.querySelectorAll("div[class='case']");
    window.addEventListener("scroll", navHighlighter); // event listener for scroll

    requestData();
  </script>
</body>

</html>