<!DOCTYPE html>
<html>
<title>r/place analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="style.css">

<script src="https://unpkg.com/d3-regression@1.3.10/dist/d3-regression.min.js"></script>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="keypoints.js"></script>
<script src="anchornav.js"></script>


<link href='https://fonts.googleapis.com/css?family=IBM Plex Sans Condensed' rel='stylesheet'>


<style type="text/css">
  .frontimg {
    position: absolute;
  }

  .backimg {
    transform: translate(0, 0);
    position: relative;
  }
</style>

<body>

  <h1 class="center">r/place Analysis</h1>

  <div class="container col">
    <video width="900" height="500" autoplay muted loop>
      <source src="images/timelapse.mp4" type="video/mp4">
    </video>

    <div class="center">
      <p>
        Starting on April 1, 2022, Reddit users collaboratively edited a 1000 pixel x 1000 pixel canvas on the r/place
        subreddit. Each user was able to change the color of a single pixel with replacement from a limited palette with
        5 minute pauses in between changes. The canvas doubled in size two times, eventually ending up 2000 pixel x 2000
        pixel large. r/place had appeared before in 2017, but the volume of contributers in the 2022 r/place far
        outshined its predecessor. Various groups, such as r/turkey, r/france, twitch audiences, etc. banded together to
        leave their mark on the canvas.
      </p>
      <div>
        <h3>Number of changes to the canvas over time</h3>
        <svg id="expo1" width="900" height="300"></svg>
      </div>

      <div class="smallmults">
        <svg id="expo2" width="440" height="300"></svg>
        <svg id="expo3" width="440" height="300"></svg>
      </div>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo
        viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus
        ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet
        non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at
        consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas
        fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed
        cras.</p>
      <div>
        <h3>Number of unique users</h3>
        <svg id="expo7" width="900" height="100"></svg>
      </div>
      <div class="smallmults hist">
        <svg id="expo4" width="440" height="300"></svg>
        <svg id="expo5" width="440" height="300"></svg>
      </div>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo
        viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus
        ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet
        non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at
        consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas
        fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed
        cras.</p>

    </div>

  </div>


  <div class="caseandnav">
    <nav class="nav">
      <h2>Highlights</h2>
      <ol>
        <li><a href="#canada">Canadian Flag</a></li>
        <li><a href="#dutch">Dutch Paintings</a></li>
        <li><a href="#creeper">Minecraft Animation</a></li>
        <li><a href="#void">The Void</a></li>
      </ol>
    </nav>

    <div id="keypoints" class="center">

      <!-- gets populated with divs for each case -->
      <!-- ex: -->
      <!-- <div>
          <h3></h3>
          <p></p>
          <svg></svg>
          <p></p>
        </div> -->


    </div>

  </div>
  <div>
    <svg class="frontimg" height="500" width="500">
      <image
        xlink:href="https://gistcdn.githack.com/massimocarbone/16d0190aa6c4084f9c276c5f79e52f52/raw/5809c97bce6188714ef8f79d07cc61c1152ef357/canada.svg"
        class="frontimg" width="500" height="500" />
    </svg>
    <svg class="backimg" height="500" width="500">
      <defs>
        <clipPath id="mask">
          <circle id="mask-circle" cx="50%" cy="50%" r="8%" style="fill: #ffffff" />
        </clipPath>
      </defs>
      <g clip-path="url(#mask)">
        <rect width="100%" height="100%" fill="#272730" />
        <image
          xlink:href="https://gistcdn.githack.com/massimocarbone/caf065693c770dafec3572f6ddd43f63/raw/4418887eb0e73bfdfaad8e664d06f17a736d8772/back.svg"
          width="100%" height="100%" />
      </g>
      <circle id="circle-shadow" cx="50%" cy="50%" r="8%" style="stroke: #fff; fill: transparent; stroke-width: 5;" />
    </svg>
  </div>


  <script>
    const color_17 = '#9932a8'
    const color_22 = '#439abf'

    async function tileschart(data, svgId, color, category) {

      const svg = d3.select("#" + svgId);
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat('')
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      // Credit: Legend based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 5 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 20)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category);

      loessRegression = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg = loessRegression(data)

      let lineGen = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      let line = chart.append("path")
        .datum(data_reg)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color)
        .attr("stroke-width", 1)
        .attr("d", lineGen);

      // Credit: Tooltip based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let tooltip = chart.append("div")
        .attr('id', svgId + 'tooltip')
        .style('position', 'absolute')
        .style("background-color", "#D3D3D3")
        .style('padding', 6)
        .style('display', 'none')

      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", svgId + "mouse-over-effects");

      mouseG.append("line")
        .attr("class", svgId + "mouse-line")
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', height)
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", svgId + "mouse-per-line");

      mousePerLine.append("circle")
        .attr("r", 4)
        .style("stroke", color)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line text")
            .style("opacity", "0");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'none')

        })
        .on('mouseover', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "1");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "1");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'block')
        })
        .on('mousemove', event => {
          let mouse = d3.pointer(event);

          let time = timeScale.invert(mouse[0])
          let bisect = d3.bisector(function (d) { return d['min_from_zero']; }).left
          let idx = bisect(data, time);
          idx = idx < 0 ? 0 : (idx >= data.length ? data.length - 1 : idx);

          d3.selectAll("." + svgId + "mouse-line")
            .attr("x1", mouse[0])
            .attr("x2", mouse[0]);

          d3.selectAll("." + svgId + "mouse-per-line")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data[idx]['count']) + ")");

          // TODO: not working yet, wip
          tooltip.html(data[idx]['count'])
            .style('display', 'block')
            .style('left', mouse[0] + 20)
            .style('top', mouse[1] - 20)
            .style('font-size', 11.5);
        });
    }

    async function tileschartmultiple(data1, data2, svgId, color1, color2, category1, category2) {

      const svg = d3.select("#" + svgId);
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const data = d3.merge([data1, data2])

      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });;
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 0 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 40)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color1);

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 20)
        .attr("r", radius)
        .style("fill", color2);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category1);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", 20 + radius / 2)
        .style("font-size", 12)
        .text(category2);

      loessRegression1 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg1 = loessRegression1(data1)

      let lineGenr1 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg1)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color1)
        .attr("stroke-width", 2)
        .attr("d", lineGenr1);

      loessRegression2 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg2 = loessRegression2(data2)

      let lineGenr2 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen2 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg2)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color2)
        .attr("stroke-width", 2)
        .attr("d", lineGenr2);

      // Credit: Tooltip based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let tooltip = chart.append("div")
        .attr('id', svgId + 'tooltip')
        .style('position', 'absolute')
        .style("background-color", "#D3D3D3")
        .style('padding', 6)
        .style('display', 'none')

      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", svgId + "mouse-over-effects");

      mouseG.append("line")
        .attr("class", svgId + "mouse-line")
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', height)
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", svgId + "mouse-per-line");

      mousePerLine.append("circle")
        .attr("r", 4)
        .attr("id", svgId + "mouse1")
        .style("stroke", color1)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");
      mousePerLine.append("circle")
        .attr("r", 4)
        .attr("id", svgId + "mouse2")
        .style("stroke", color2)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line text")
            .style("opacity", "0");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'none')

        })
        .on('mouseover', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "1");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "1");
          d3.selectAll("#" + svgId + "tooltip")
            .style('display', 'block')
        })
        .on('mousemove', event => {
          let mouse = d3.pointer(event);

          let time = timeScale.invert(mouse[0])
          let bisect = d3.bisector(function (d) { return d['min_from_zero']; }).left;
          let idx1 = bisect(data1, time);
          idx1 = idx1 < 0 ? 0 : (idx1 >= data1.length ? data1.length - 1 : idx1);
          let idx2 = bisect(data2, time);
          idx2 = idx2 < 0 ? 0 : (idx2 >= data2.length ? data2.length - 1 : idx2);

          d3.selectAll("." + svgId + "mouse-line")
            .attr("x1", mouse[0])
            .attr("x2", mouse[0]);

          d3.select("#" + svgId + "mouse1")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data1[idx1]['count']) + ")");

          d3.select("#" + svgId + "mouse2")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data2[idx2]['count']) + ")");

          // TODO: not working yet, wip
          tooltip.html(data1[idx1]['count'])
            .style('display', 'block')
            .style('left', mouse[0] + 20)
            .style('top', mouse[1] - 20)
            .style('font-size', 11.5);

        });
    }

    async function histogram(data, svgId, color) {
      data.forEach(d => {
        d["users"] = parseInt(d["users"]);
        d["posts"] = parseInt(d["posts"]);
      })
      let num_bins = 50;
      data = data.filter(d => d['posts'] <= num_bins);

      const svg = d3.select("#" + svgId);
      const margin = { top: 10, right: 10, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const postExtent = d3.extent(data, d => d['posts']);
      const postScale = d3.scaleLinear().domain(postExtent).range([0, width]);


      const userExtent = d3.extent(data, d => d['users']);
      const userScale = d3.scaleLinear().domain(userExtent).range([height, 0]);

      let leftAxis = d3.axisLeft(userScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(userScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(postScale);
      let bottomGridlines = d3.axisBottom(postScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Users");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("# of Changes");


      // Bars
      svg.selectAll("rect")
        .data(data)
        .enter()
        .append("rect")
        .attr("users", d => d["users"])
        .attr("num_posts", d => d["posts"])
        .attr("x", d => margin.left + postScale(d["posts"]))
        .attr("y", d => margin.top + userScale(d["users"]))
        .attr("width", 5)
        .attr("height", d => height - userScale(d['users']))
        .style("fill", color);
    }

    async function barCompare(data1, data2, svgId) {
      let data1_sum = 1166924
      let data2_sum = 10381164

      const svg = d3.select("#" + svgId);
      const margin = { top: 10, right: 150, bottom: 20, left: 20 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;


      const postExtent = [0, 10381164];
      const postScale = d3.scaleLinear()
        .domain(postExtent)
        .range([0, width])



      // Bars
      svg
        .append("rect")
        .attr("class", "2017users")
        .attr("number", data1_sum)
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", postScale(data1_sum))
        .attr("height", height / 2)
        .style("fill", color_17);

      svg
        .append("rect")
        .attr("class", "2022users")
        .attr("number", data2_sum)
        .attr("x", margin.left)
        .attr("y", margin.top + margin.top + (height / 2))
        .attr("width", postScale(data2_sum))
        .attr("height", height / 2)
        .style("fill", color_22);

      let annotations = svg.append("g").attr("id", svgId + "annotations");

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", margin.left + 10)
        .attr("y", height / 2 - 5)
        .style("fill", "white")
        .text("2017");

      annotations.append("text")
        .attr("class", "inbarsubtext")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data1_sum) + margin.left + 5)
        .attr("y", height / 2)
        .style("fill", color_17)
        .text("unique users");
      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data1_sum) + margin.left + 5)
        .attr("y", height / 2 - 15)
        .style("fill", color_17)
        .text(data1_sum.toLocaleString("en-US"));

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", margin.left + 10)
        .attr("y", height + 5)
        .style("fill", "white")
        .text("2022");

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data2_sum) + margin.left + 5)
        .attr("y", height)
        .style("fill", color_22)
        .text(data2_sum.toLocaleString("en-US"));
      annotations.append("text")
        .attr("class", "inbarsubtext")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data2_sum) + margin.left + 5)
        .attr("y", height + 15)
        .style("fill", color_22)
        .text("unique users");
    }


    /**
     *  Data should be given in a 2d array with the value being the
     *  number of changes for for a pixel at (row, col).
     *  DivId should be the id for the div that the heatmap will be
     *  nested inside.
     *  PixelSize should be the size of each pixel in the heatmap.
     * 
     *  Credit: Adapted from https://jeffrz.github.io/info4310-sp2022/notes/22.04.25.notes.htm
     **/
    async function heatmap(data, svg, pixelSize, heatmap_color) {

      svg.selectAll("*").remove();
      svg.selectAll()
        .data(data)
        .enter()
        .append('rect')
        .attr("height", pixelSize)
        .attr("width", pixelSize)
        .attr("x", cell => { return cell.x * pixelSize })
        .attr("y", cell => { return cell.y * pixelSize })
        .attr("fill", cell => {
          let color = d3.color(heatmap_color(cell.value));
          color.opacity = 0.5;
          return color + "";
        });

      // let canvas = div.select("#" + divId + "canvas");
      // canvas.remove();

      // canvas = div.append('canvas')
      //   .attr('width', width)
      //   .attr('height', height)
      //   .attr('id', divId + 'canvas');

      // let context = canvas.node().getContext('2d');

      // let gray = d3.color("gray");
      // gray.opacity = 0.5;

      // // bind the data to canvas elements
      // heatmap_changes.selectAll('changes.rect')
      //   .data(data)
      //   .enter()
      //   .append('changes')
      //   .attr('class', 'rect')
      //   .attr("height", pixelSize)
      //   .attr("width", pixelSize)
      //   .attr("x", cell => { return cell.x * pixelSize })
      //   .attr("y", cell => { return cell.y * pixelSize })
      //   .attr("fillStyle", cell => {
      //     let color = d3.color(heatmap_color(cell.value));
      //     if (color) {
      //       color.opacity = 0.5;
      //       return color + "";
      //     } else {
      //       return gray + "";
      //     }
      //   });

      // context.clearRect(0, 0, width, height);

      // heatmap_changes.selectAll('changes.rect')
      //   .each(function (d, i) {
      //     let node = d3.select(this);
      //     context.beginPath();
      //     context.rect(node.attr('x'),
      //       node.attr('y'),
      //       node.attr('width'),
      //       node.attr('height'));
      //     context.fillStyle = node.attr('fillStyle');
      //     context.fill();
      //   });
    }

    async function heatmapOverTime(dataArray, divId, pixelSize) {

      let sliderDiv = document.getElementById(divId);
      sliderDiv.innerHTML += "<input type='range' style='width:10em' id='" + divId + "slider' name='" + divId + "slider' min='0' max='" + (dataArray.length - 1) + "' value='0'>";

      let slider = document.querySelector("#" + divId + "slider");

      // First snapshot's width & height
      let width = dataArray[0][0].length * pixelSize;
      let height = dataArray[0].length * pixelSize;

      // Flattened array for each snapshot
      let data1DArray = [];
      let calc1DArray = [];
      let min = Number.MAX_VALUE;
      let max = 0;
      for (let idx = 0; idx < dataArray.length; idx++) {
        let data = dataArray[idx];
        data1DArray.push([]);
        data.forEach((row, i) => {
          row.forEach((val, j) => {
            data[i][j] = parseFloat(val);
            data1DArray[idx].push({
              'x': j,
              'y': i % width,
              'value': parseFloat(val)
            });
          });
        });
        let calc1D = dataArray[idx].flat();
        calc1DArray.push(calc1D);
        min = Math.min(min, d3.min(calc1D));
        max = Math.max(max, d3.max(calc1D));
      }

      let heatmap_color = d3.scaleSequential()
        .interpolator(d3.interpolateViridis)
        .domain([min, max])

      let svg = d3.select("#" + divId)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("id", "#" + divId + "svg");

      // let changes = document.createElement('changes');
      // let heatmap_changes = d3.select(changes);

      heatmap(data1DArray[0], svg, pixelSize, heatmap_color);
      slider.addEventListener('input', function () {
        heatmap(data1DArray[slider.value], svg, pixelSize, heatmap_color);
      });

    }

    /**
     * When adding a key point, make sure to also call:
     *      heatmap(<data>, <heatmapname>, <pixelSize>);
     * in the requestData() function. 
     * <heatmapname> should match the heatmapname for the new key point.
     **/
    addKeypoint(
      title = "Canadian Flag",
      divname = "canada",
      heatmapname = "canadianflag",
      imglist = [["Canada_Timelapse.gif", "This is a timelapse of the Canada Flag. Notice the difficulty in trying to make the leaf, and even with some of the text. The Canada flag was a huge meme, it was Bananas!"],
      ["Canada_Germans.png", "Many Canada flag memes spouted from this."],
      ["Canada_Wales.png", ""]],
      paragraph1 = "In a comical turn of events, what began as a collaborative effort between those at r/Canada to create a depiction of the Canadian flag turned into a failed attempt at drawing a maple leaf that spanned nearly the entirety of r/place\’\s existence. Canada\’\s flag quickly became the target of memes as their leaf was never quite in shape. This led to constant vandalism of the flag. At one point, the flag was changed to yellow and the leaf changed to a banana. Canada managed to gain a little progress on their leaf, however the canvas ended before it could be fully completed.",
      paragraph2 = ""
    )

    addKeypoint(
      title = "Dutch Paintings",
      divname = "dutch",
      heatmapname = "dutchpaintings",
      imglist = [],
      paragraph1 = "An incredibly accurate recreation of very famous dutch paintings such as Vermeer\’\s \“\Girl with a Pearl Earring\”\, Rembrandt’\s\ \“\The Night Watch\”\, and a famous painting depicting Michael de Ruyter\’\s naval battle, a source of immense pride for the Netherlands. In addition, the users at r/placeNL decided to help out those at r/canada in producing a Canadian flag for them, an interesting reflection of the relationship between Canada and Netherlands stemming from WW2 where Canadian troops were among the first to liberate many occupied Dutch cities.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "Minecraft Loading Screen Animation",
      divname = "creeper",
      heatmapname = "creeperanimation",
      imglist = [["Minecraft_Timelapse.gif", "This is a timelapse of the Minecraft loading animation as it occured in r/place. Note that this took huge coordination, which is why the fact the streamers and their community organized this to make an animation is an incredible feat."]],
      paragraph1 = "This is where the Minecraft loading screen animation took place, which was one of the most upvoted posts on r/place. The animation was created by streamers NymN and Zoil.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )

    addKeypoint(
      title = "The Void",
      divname = "void",
      heatmapname = "voidmap",
      imglist = [["Void_Timelapse.gif", "This is a timelapse of one of the biggest examples of the void, the large phenomenon of r/place. Notice the eventual creation of the face, which is clearly shown in the heatmap as an area of high activity."],
      ["Void_Consume.gif", "Void consume all."]],
      paragraph1 = "\“\The Void\”\ refers to several distorted images and art present nearly at all times of r/place\’\s existence, especially as many griefers would try their best to destroy art around the canvas. In addition, The Void, in its final moments, was a large area of black pixels consuming art wherever it spread. After the main void was destroyed by The First Hand, it moved up TotalBiscuit\’\s hair and reformed right before the canvas ended. Created by The Swarm.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )



    function csvToArray(csv) {
      rows = csv.split("\n");
      return rows.map(function (row) {
        return row.split(",");
      });
    };

    const requestData = async () => {

      let tileData2017 = await d3.csv("data/2017_time_data.csv");
      tileData2017.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      let tileData2022 = await d3.csv("data/2022_time_data.csv");
      tileData2022.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      tileschartmultiple(tileData2017, tileData2022, 'expo1', color_17, color_22, 2017, 2018);
      tileschart(tileData2017, 'expo2', color_17, 2017);
      tileschart(tileData2022, 'expo3', color_22, 2022);


      let userData2017 = await d3.csv("data/2017_user_data.csv");
      histogram(userData2017, 'expo4', color_17);

      let userData2022 = await d3.csv("data/2022_user_data.csv");
      histogram(userData2022, 'expo5', color_22);

      barCompare(userData2017, userData2022, "expo7");

      // TODO: replace testData with real data
      const canadianflagData33 = await d3.text("data/canada_norm_updates_33.csv");
      const canadianflagData66 = await d3.text("data/canada_norm_updates_66.csv");
      const canadianflagData100 = await d3.text("data/canada_norm_updates_100.csv");
      const canadaDataArr = [csvToArray(canadianflagData33), csvToArray(canadianflagData66), csvToArray(canadianflagData100)]
      heatmapOverTime(canadaDataArr, 'canadianflag', 10);

      const dutchData33 = await d3.text("data/dutch_norm_updates_33.csv");
      const dutchData66 = await d3.text("data/dutch_norm_updates_66.csv");
      const dutchData100 = await d3.text("data/dutch_norm_updates_100.csv");
      const dutchDataArr = [csvToArray(dutchData33), csvToArray(dutchData66), csvToArray(dutchData100)]
      heatmapOverTime(dutchDataArr, 'dutchpaintings', 2);

      const minecraftData33 = await d3.text("data/minecraft_norm_updates_33.csv");
      const minecraftData66 = await d3.text("data/minecraft_norm_updates_66.csv");
      const minecraftData100 = await d3.text("data/minecraft_norm_updates_100.csv");
      const minecraftDataArr = [csvToArray(minecraftData33), csvToArray(minecraftData66), csvToArray(minecraftData100)]
      heatmapOverTime(minecraftDataArr, 'creeperanimation', 10);

      const voidData33 = await d3.text("data/void_norm_updates_33.csv");
      const voidData66 = await d3.text("data/void_norm_updates_66.csv");
      const voidData100 = await d3.text("data/void_norm_updates_100.csv");
      const voidDataArr = [csvToArray(voidData33), csvToArray(voidData66), csvToArray(voidData100)]
      heatmapOverTime(voidDataArr, 'voidmap', 2);

    }


    // for the dynamic styling on the anchor nav sidebar--
    // this must stay at the bottom of the script to work
    const sections = document.querySelectorAll("div[class='case']");
    window.addEventListener("scroll", navHighlighter); // event listener for scroll

    requestData();
  </script>
  <script type="text/javascript">

    var svgElement = document.querySelector('svg');
    var maskedElement = document.querySelector('#mask-circle');
    var circleFeedback = document.querySelector('#circle-shadow');
    var svgPoint = svgElement.createSVGPoint();

    function cursorPoint(e, svg) {
      svgPoint.x = e.clientX;
      svgPoint.y = e.clientY;
      return svgPoint.matrixTransform(svg.getScreenCTM().inverse());
    }

    function update(svgCoords) {
      maskedElement.setAttribute('cx', svgCoords.x);
      maskedElement.setAttribute('cy', svgCoords.y);
      circleFeedback.setAttribute('cx', svgCoords.x);
      circleFeedback.setAttribute('cy', svgCoords.y);
    }

    window.addEventListener('mousemove', function (e) {
      update(cursorPoint(e, svgElement));
    }, false);

    document.addEventListener('touchmove', function (e) {
      e.preventDefault();
      var touch = e.targetTouches[0];
      if (touch) {
        update(cursorPoint(touch, svgElement));
      }
    }, false);


  </script>
</body>

</html>