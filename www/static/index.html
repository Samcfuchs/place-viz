<!DOCTYPE html>
<html>
<title>r/place analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="style.css">

<script src="https://unpkg.com/d3-regression@1.3.10/dist/d3-regression.min.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="keypoints.js"></script>
<script src="anchornav.js"></script>
<script src="legend.js"></script>

<style type="text/css">
  .frontimg {
    position: absolute;
  }

  .backimg {
    transform: translate(0, 0);
    position: relative;
  }
</style>

<body>

  <h1 class="center">r/place Analysis</h1>

  <div class="container col">
    <video width="900" height="500" autoplay muted loop>
      <source src="images/timelapse.mp4" type="video/mp4">
    </video>

    <div class="center">
      <p>
        On April 1, 2022, Reddit users across the world took part in a collaborative project and social experiment on
        the subreddit r/place. Registered reddit users could choose from a limited color palette and place a single
        colored pixel on a 1000 x 1000 pixel canvas. They would have to wait for a certain amount of time, between 5 to
        20 minutes, before being able to place another pixel. This meant that redditors needed to collaborate with each
        other to effectively create, defend, or attack images on the canvas. Various groups, such as r/turkey, r/canada,
        twitch audiences, etc. banded together to
        leave their mark on the canvas.
      </p>

      <div>
        <h3>Number of unique users</h3>
        <svg id="expo7" width="900" height="100"></svg>
      </div>
      <div class="smallmults hist">
        <svg id="expo4" width="440" height="300"></svg>
        <svg id="expo5" width="440" height="300"></svg>
      </div>

      <p>
        This project had occurred once before on April 1, 2017 and drew the attention of over 1 million users. The
        2022 edition drew even more popularity with over 10 million users over its four day timespan. While the 2017
        version had a 16 color palette, the 2022 version gradually added 16 more colors to its palette. In addition, the
        volume of changes and users eventually led to the 2022 canvas doubling in size 2 times, eventually ending up
        2000 x 2000 pixels large.
      </p>
      <p>
        As shown in the graphs above, while the volume of users in 2022 far surpassed that of 2017, the distribution of
        contributions each user made was about the same. This means that the vast majority of users made 1 change to the
        canvas. A large portion of this group of users is likely made up of the r/place lurkers and passbyers who placed
        a pixel out of curiosity. The graphs also show a number of dedicated r/place contributors who made multiple
        changes. As the number of changes increase, however, the number of users who made that amount of changes
        decreases logrithmically. While there were users that made more than 50 changes, we limited the domain because
        there were many users that made a small number of contributions and few users that made an extremely large
        number of contributions, which would have created a skewed representation in the histogram. Because of the large
        volume of changes and the fact that bots were a known problem on r/place, we suspect that the majority of users
        with large amounts of contributions were bots.
      </p>

      <div>
        <h3>Number of changes to the canvas over time</h3>
        <svg id="expo1" width="900" height="300"></svg>
      </div>

      <p>
        Again, the graph above emphasizes the difference in volume between 2017 r/place and 2022 r/place. It seems like
        2022 had large variability in number of changes over time while 2017 did not, but that is simply because the
        volume of changes in 2022 obscures the variability in number of changes over time in 2017. The graphs below
        provide more clarification.
      </p>

      <div class="smallmults">
        <svg id="expo2" width="440" height="300"></svg>
        <svg id="expo3" width="440" height="300"></svg>
      </div>
      <p>
        In 2017, r/place appeared on the internet for the first time. Its beginnings were marked by random pixel
        placements and disordered attempts at creating distinguisable images on the canvas. As people became more
        familiar with the rules behind the experiment, coordinated efforts by various subreddit communities began to
        appear. This phenomenon is reflected on the left graph, showing how r/place started out with relatively few
        contributions but with time, grew in popularity.
        In 2022, on the other hand, r/place returned with a blaze of activity. Because it had already occurred 5 years
        before, some people were already familiar with the mechanisms of the project and various subreddit communities
        immediately started coordinating efforts to put their mark on the canvas. This is shown in the left graph by how
        r/place started out with a large wave of contributions before leveling off more sustainable amounts.
      </p>


    </div>

  </div>


  <div class="caseandnav">
    <nav class="nav">
      <h2>Highlights</h2>
      <ol>
        <li><a href="#canada">Canadian Flag</a></li>
        <li><a href="#creeper">Minecraft Animation</a></li>
        <li><a href="#void">The Void</a></li>
      </ol>
    </nav>

    <div id="keypoints" class="center">

      <!-- gets populated with divs for each case -->
      <!-- ex: -->
      <!-- <div>
          <h3></h3>
          <p></p>
          <svg></svg>
          <p></p>
        </div> -->


    </div>

  </div>



  <script>
    const color_17 = '#9932a8'
    const color_22 = '#439abf'
    var backgroundImages = {
        canadianflag: "https://gistcdn.githack.com/massimocarbone/593ce62012923c2c1e146ed0a405ded3/raw/b17ccaee276477ba479519336d9c91babd3ff3f5/canada1.svg",
        creeperanimation: "https://gistcdn.githack.com/massimocarbone/450864dac9719dd60e898c3a06373ead/raw/c7ba2a01f42868de63092d35f8bac5fa05bf76db/creeper66.svg",
        voidmap: "https://gistcdn.githack.com/massimocarbone/118eba083cf1d0630ed22c86c9879ee2/raw/5a20fd50d9e4ad84937e2c7ff75ed9c47ed863c7/void1.svg"
    };
    var backgroundCount = 1;

    async function tileschart(data, svgId, color, category) {

      const svg = d3.select("#" + svgId);
      console.log(svgId)
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        console.log(data)
      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat('')
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      // Credit: Legend based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 5 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 20)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category);

        loessRegression = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg = loessRegression(data)

      let lineGen = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      let line = chart.append("path")
        .datum(data_reg)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color)
        .attr("stroke-width", 1)
        .attr("d", lineGen);

      let tooltipWidth = 50;
      let tooltipHeight = 30;

      let tooltip = chart.append("g")
        .attr('id', svgId + 'tooltip')
        .attr("visibility", "hidden")
        .attr("class", "tooltip");

      tooltip.append("rect")
        .attr("fill", "lightgray")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let tooltipText = tooltip.append("text")
        .attr("fill", "black")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 10);

      // Credit: Tooltip Line based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", svgId + "mouse-over-effects");

      mouseG.append("line")
        .attr("class", svgId + "mouse-line")
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', height)
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", svgId + "mouse-per-line");

      mousePerLine.append("circle")
        .attr("r", 4)
        .style("stroke", color)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line text")
            .style("opacity", "0");
          tooltip.style("visibility", "hidden");
        })
        .on('mouseover', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "1");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "1");
          tooltip.style("visibility", "visible");
        })
        .on('mousemove', event => {
          let mouse = d3.pointer(event);

          let time = timeScale.invert(mouse[0])
          let bisect = d3.bisector(function (d) { return d['min_from_zero']; }).left
          let idx = bisect(data, time);
          idx = idx < 0 ? 0 : (idx >= data.length ? data.length - 1 : idx);

          d3.selectAll("." + svgId + "mouse-line")
            .attr("x1", mouse[0])
            .attr("x2", mouse[0]);

          d3.selectAll("." + svgId + "mouse-per-line")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data[idx]['count']) + ")");

          tooltipText.text(data[idx]['count']);
          tooltip.attr("transform", `translate(${(mouse[0] + 30)},${mouse[1] - 20})`);
        });
    }



    async function tileschartmultiple(data1, data2, svgId, color1, color2, category1, category2) {

      const svg = d3.select("#" + svgId);
      const margin = { top: 15, right: 15, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const data = d3.merge([data1, data2])

      const countExtent = d3.extent(data, d => d['count']);
      const countScale = d3.scaleLinear().domain(countExtent).range([height, 0]);
      const timeExtent = d3.extent(data, d => d['min_from_zero']);
      const timeScale = d3.scaleLinear().domain(timeExtent).range([0, width]);

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });;
      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(timeScale)
      let bottomGridlines = d3.axisBottom(timeScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Changes");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("Time");

      let legend = chart.append('g')
        .attr('class', 'legend')
        .attr("transform", "translate(" + (width - 40) + "," + 0 + ")");

      legend.append("rect")
        .attr("class", "legend-background")
        .attr("x", -15)
        .attr("y", -10)
        .attr("width", 60)
        .attr("height", 40)
        .style("fill", "white");

      let radius = 6;

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", radius)
        .style("fill", color1);

      legend.append("circle")
        .attr("class", "legend-node")
        .attr("cx", 0)
        .attr("cy", 20)
        .attr("r", radius)
        .style("fill", color2);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", radius / 2)
        .style("font-size", 12)
        .text(category1);

      legend.append("text")
        .attr("class", "legend-text")
        .attr("x", radius * 2)
        .attr("y", 20 + radius / 2)
        .style("font-size", 12)
        .text(category2);

      loessRegression1 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg1 = loessRegression1(data1)

      let lineGenr1 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen1 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg1)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color1)
        .attr("stroke-width", 2)
        .attr("d", lineGenr1);

      loessRegression2 = d3.regressionLoess()
        .x(d => d['min_from_zero'])
        .y(d => d['count'])
        .bandwidth(0.009);

      let data_reg2 = loessRegression2(data2)

      let lineGenr2 = d3.line()
        .x(d => timeScale(d[0]))
        .y(d => countScale(d[1]))
        .curve(d3.curveMonotoneX)

      let lineGen2 = d3.line()
        .x(d => timeScale(d['min_from_zero']))
        .y(d => countScale(d['count']))

      chart.append("path")
        .datum(data_reg2)
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", color2)
        .attr("stroke-width", 2)
        .attr("d", lineGenr2);

      let tooltipWidth = 100;
      let tooltipHeight = 50;

      let tooltip = chart.append("g")
        .attr('id', svgId + 'tooltip')
        .attr("visibility", "hidden")
        .attr("class", "tooltip");

      tooltip.append("rect")
        .attr("fill", "lightgray")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let tooltipText1 = tooltip.append("text")
        .attr("fill", "black")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 10);

      let tooltipText2 = tooltip.append("text")
        .attr("fill", "black")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 30);

      // Credit: Tooltip Line based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", svgId + "mouse-over-effects");

      mouseG.append("line")
        .attr("class", svgId + "mouse-line")
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', height)
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", svgId + "mouse-per-line");

      mousePerLine.append("circle")
        .attr("r", 4)
        .attr("id", svgId + "mouse1")
        .style("stroke", color1)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");
      mousePerLine.append("circle")
        .attr("r", 4)
        .attr("id", svgId + "mouse2")
        .style("stroke", color2)
        .style("fill", "none")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line text")
            .style("opacity", "0");
          tooltip.style("visibility", "hidden");

        })
        .on('mouseover', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "1");
          d3.selectAll("." + svgId + "mouse-per-line circle")
            .style("opacity", "1");
          tooltip.style("visibility", "visible");
        })
        .on('mousemove', event => {
          let mouse = d3.pointer(event);

          let time = timeScale.invert(mouse[0])
          let bisect = d3.bisector(function (d) { return d['min_from_zero']; }).left;
          let idx1 = bisect(data1, time);
          idx1 = idx1 < 0 ? 0 : (idx1 >= data1.length ? data1.length - 1 : idx1);
          let idx2 = bisect(data2, time);
          idx2 = idx2 < 0 ? 0 : (idx2 >= data2.length ? data2.length - 1 : idx2);

          d3.selectAll("." + svgId + "mouse-line")
            .attr("x1", mouse[0])
            .attr("x2", mouse[0]);

          d3.select("#" + svgId + "mouse1")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data1[idx1]['count']) + ")");

          d3.select("#" + svgId + "mouse2")
            .attr("transform", "translate(" + mouse[0] + "," + countScale(data2[idx2]['count']) + ")");

          tooltipText1.text(category1 + ": " + data1[idx1]['count']);
          tooltipText2.text(category2 + ": " + data2[idx2]['count']);
          tooltip.attr("transform", `translate(${(mouse[0] + 60)},${mouse[1] - 35})`);

        });
    }

    async function histogram(data, svgId, color) {
      data.forEach(d => {
        d["users"] = parseInt(d["users"]);
        d["posts"] = parseInt(d["posts"]);
      })
      let num_bins = 50;
      data = data.filter(d => d['posts'] <= num_bins);

      const svg = d3.select("#" + svgId);
      const margin = { top: 10, right: 10, bottom: 65, left: 80 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", svgId + "annotations");
      let chart = svg.append("g").attr("id", svgId + "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const postExtent = d3.extent(data, d => d['posts']);
      const postScale = d3.scaleLinear().domain(postExtent).range([0, width]);


      const userExtent = d3.extent(data, d => d['users']);
      const userScale = d3.scaleLinear().domain(userExtent).range([height, 0]);

      let leftAxis = d3.axisLeft(userScale)
        .tickFormat(function (d) {
          if ((d / 1000000) >= 1) {
            d = d / 1000000 + "M";
          } else if ((d / 1000) >= 1) {
            d = d / 1000 + "K";
          }
          return d;
        });
      let leftGridlines = d3.axisLeft(userScale)
        .tickSize(-width - 10)
        .tickFormat("");
      let bottomAxis = d3.axisBottom(postScale);
      let bottomGridlines = d3.axisBottom(postScale)
        .tickSize(-height - 10)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxis);
      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlines);
      annotations.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("x", -height / 2)
        .attr("y", 15)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("# of Users");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomAxis);
      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (height + margin.top + 10) + ")")
        .call(bottomGridlines);
      annotations.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width / 2 + margin.left)
        .attr("y", height + margin.bottom)
        .text("# of Changes");

      let tooltipWidth = 50;
      let tooltipHeight = 30;

      let tooltip = chart.append("g")
        .attr('id', svgId + 'tooltip')
        .attr("visibility", "hidden")
        .attr("class", "tooltip");

      tooltip.append("rect")
        .attr("fill", "lightgray")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let tooltipText = tooltip.append("text")
        .attr("fill", "black")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 10);

      // Credit: Tooltip Line based on https://bl.ocks.org/dianaow/0da76b59a7dffe24abcfa55d5b9e163e
      let lineStroke = "2px";

      let mouseG = chart.append("g")
        .attr("class", svgId + "mouse-over-effects");

      mouseG.append("line")
        .attr("class", svgId + "mouse-line")
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', height)
        .style("stroke", "#A9A9A9")
        .style("stroke-width", lineStroke)
        .style("opacity", "0");

      let mousePerLine = mouseG.append("g")
        .attr("class", svgId + "mouse-per-line");

      mouseG.append('svg:rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "0");
          d3.selectAll("." + svgId + "mouse-per-line text")
            .style("opacity", "0");
          tooltip.style("visibility", "hidden");
        })
        .on('mouseover', function () {
          d3.select("." + svgId + "mouse-line")
            .style("opacity", "1");
          tooltip.style("visibility", "visible");
        })
        .on('mousemove', event => {
          let mouse = d3.pointer(event);

          let post = postScale.invert(mouse[0])
          let bisect = d3.bisector(function (d) { return d['posts']; }).left
          let idx = bisect(data, post);
          idx = idx < 0 ? 0 : (idx >= data.length ? data.length - 1 : idx);

          d3.selectAll("." + svgId + "mouse-line")
            .attr("x1", mouse[0])
            .attr("x2", mouse[0]);

          d3.selectAll("." + svgId + "mouse-per-line")
            .attr("transform", "translate(" + mouse[0] + "," + userScale(data[idx]['users']) + ")");

          tooltipText.text(data[idx]['users']);
          tooltip.attr("transform", `translate(${(mouse[0] + 30)},${mouse[1] - 20})`);
        });

      // Bars
      chart.selectAll(svgId + "rect")
        .data(data)
        .enter()
        .append("rect")
        .attr("users", d => d["users"])
        .attr("num_posts", d => d["posts"])
        .attr("x", d => postScale(d["posts"]))
        .attr("y", d => userScale(d["users"]))
        .attr("width", 5)
        .attr("height", d => height - userScale(d['users']))
        .attr("class", svgId + "rect")
        .style("fill", color);

    }

    async function barCompare(data1, data2, svgId) {
      let data1_sum = 1166924
      let data2_sum = 10381164

      const svg = d3.select("#" + svgId);
      const margin = { top: 10, right: 150, bottom: 20, left: 20 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;


      const postExtent = [0, 10381164];
      const postScale = d3.scaleLinear()
        .domain(postExtent)
        .range([0, width])



      // Bars
      svg
        .append("rect")
        .attr("class", "2017users")
        .attr("number", data1_sum)
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", postScale(data1_sum))
        .attr("height", height / 2)
        .style("fill", color_17);

      svg
        .append("rect")
        .attr("class", "2022users")
        .attr("number", data2_sum)
        .attr("x", margin.left)
        .attr("y", margin.top + margin.top + (height / 2))
        .attr("width", postScale(data2_sum))
        .attr("height", height / 2)
        .style("fill", color_22);

      let annotations = svg.append("g").attr("id", svgId + "annotations");

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", margin.left + 10)
        .attr("y", height / 2 - 5)
        .style("fill", "white")
        .text("2017");

      annotations.append("text")
        .attr("class", "inbarsubtext")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data1_sum) + margin.left + 5)
        .attr("y", height / 2)
        .style("fill", color_17)
        .text("unique users");
      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data1_sum) + margin.left + 5)
        .attr("y", height / 2 - 15)
        .style("fill", color_17)
        .text(data1_sum.toLocaleString("en-US"));

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", margin.left + 10)
        .attr("y", height + 5)
        .style("fill", "white")
        .text("2022");

      annotations.append("text")
        .attr("class", "inbarcount")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data2_sum) + margin.left + 5)
        .attr("y", height)
        .style("fill", color_22)
        .text(data2_sum.toLocaleString("en-US"));
      annotations.append("text")
        .attr("class", "inbarsubtext")
        .attr("text-anchor", "start")
        .attr('dominant-baseline', "middle")
        .attr("x", postScale(data2_sum) + margin.left + 5)
        .attr("y", height + 15)
        .style("fill", color_22)
        .text("unique users");
    }


    /**
     *  Data should be given in a 2d array with the value being the
     *  number of changes for for a pixel at (row, col).
     *  DivId should be the id for the div that the heatmap will be
     *  nested inside.
     *  PixelSize should be the size of each pixel in the heatmap.
     * 
     *  Credit: Adapted from https://jeffrz.github.io/info4310-sp2022/notes/22.04.25.notes.htm
     **/
    async function heatmap(data, svg, pixelSize, heatmap_color) {

      svg.selectAll("*").remove();
      svg.selectAll()
        .data(data)
        .enter()
        .append('rect')
        .attr("height", pixelSize)
        .attr("width", pixelSize)
        .attr("x", cell => { return cell.x * pixelSize })
        .attr("y", cell => { return cell.y * pixelSize })
        .attr("fill", cell => {
          let color = d3.color(heatmap_color(cell.value));
          return color + "";
        });
    }

    async function heatmapOverTime(dataArray, divId, pixelSize) {

      // First snapshot's width & height
      let width = dataArray[0][0].length * pixelSize;
      let height = dataArray[0].length * pixelSize;

      // Flattened array for each snapshot
      let data1DArray = [];
      let calc1DArray = [];
      let min = Number.MAX_VALUE;
      let max = 0;
      for (let idx = 0; idx < dataArray.length; idx++) {
        let data = dataArray[idx];
        data1DArray.push([]);
        data.forEach((row, i) => {
          row.forEach((val, j) => {
            data[i][j] = parseFloat(val);
            data1DArray[idx].push({
              'x': j,
              'y': i % width,
              'value': parseFloat(val)
            });
          });
        });
        let calc1D = dataArray[idx].flat();
        calc1DArray.push(calc1D);
        min = Math.min(min, d3.min(calc1D));
        max = Math.max(max, d3.max(calc1D));
      }

      let heatmap_color = d3.scaleSequential()
        .interpolator(d3.interpolateViridis)
        .domain([min, max])

      let heatmapLegend = d3.select("#" + divId)
        .append("svg")
        .attr('width', 360)
        .attr('height', 90)
        .attr('class', 'legend')
        .attr("id", "#" + divId + "legend")

      legend(heatmapLegend, {
        color: heatmap_color, title: divId
      });

      let svg = d3.select("#" + divId)
        .append("svg")
        .attr("width", width + 2)
        .attr("height", height + 2)
        .attr("id", "#" + divId + "svg")
        .attr("class", "frontimg");

      heatmap(data1DArray[0], svg, pixelSize, heatmap_color);

      let svgBack = d3.select("#" + divId)
        .append("svg")
        .attr("width", width + 2)
        .attr("height", height + 2)
        .attr("id", "#" + divId + "back")
        .attr("class", "backimg");
        // potench here 
        //edit: if we put here, problem is it fucks up p elements below so we could ask to see how to keep them pos absolute too
      ////
      document.getElementById("#" + divId + "back").innerHTML += 
              "<defs> <clipPath id=mask" + backgroundCount + "> <circle id=mask-circle" + backgroundCount + " cx=50% cy=50% r=8% style=\"fill:#ffffff\"/> </clipPath> </defs>" + " <g clip-path=url(#mask"+ backgroundCount +")> <rect width=100% height=100% fill=\"#272730\" /> <image id=" + divId + "img" + " xlink:href=\"https://gistcdn.githack.com/massimocarbone/593ce62012923c2c1e146ed0a405ded3/raw/b17ccaee276477ba479519336d9c91babd3ff3f5/canada1.svg\" width=100% height=100% /> </g>" + "<circle id=circle-shadow" + backgroundCount + " cx=50% cy=50% r=8% style=\"stroke: #fff; fill: transparent; stroke-width: 5;\" />";

      //document.getElementById(divId + "img").href.animVal="../template/save.png";
      document.getElementById(divId + "img").setAttribute('xlink:href', backgroundImages[divId]);
      backgroundCount++;


      // Credit: Slider Reference https://bl.ocks.org/johnwalley/e1d256b81e51da68f7feb632a53c3518s
      let sliderStep = d3
        .sliderBottom()
        .min(0)
        .max(dataArray.length - 1)
        .width(width - 60)
        .tickFormat(d3.format(""))
        .ticks(dataArray.length - 1)
        .step(1)
        .default(0)
        .on('onchange', val => {

          heatmap(data1DArray[val], svg, pixelSize, heatmap_color);
        });

      var gStep = d3
        .select('#' + divId)
        .append('svg')
        .attr('width', width)
        .attr('height', 90)
        .attr('class', 'slider')
        .append('g')
        .attr('transform', 'translate(30,30)');

      gStep.call(sliderStep);

    }

    /**
     * When adding a key point, make sure to also call:
     *      heatmap(<data>, <heatmapname>, <pixelSize>);
     * in the requestData() function. 
     * <heatmapname> should match the heatmapname for the new key point.
     **/
    addKeypoint(
      title = "Canadian Flag",
      divname = "canada",
      heatmapname = "canadianflag",
      imglist = [["Canada_Timelapse.gif", "This is a timelapse of the Canada Flag. The Canada flag was constantly evolving and was struggling during the entire r/place event to successfully get its leaf right. Notice how they even modify Canada's name to Banana."],
      ["Canada_Germans.png", "On the contrary, other country flags had no trouble with getting their flags to look right. So Germany even mocked Canada by drawing a Canada leaf on top of their German flag."],
      ["Canada_Wales.png", "Another meme sprouted where while Canada struggles to make their leaf, other countries and r/place projects had no problem making visually appealing stuff. Here, Wales made an entire dragon. The r/place project even featured paintings and animations, which is pretty insane for a community project."]],
      paragraph1 = "In a comical turn of events, what began as a collaborative effort between those at r/Canada to create a depiction of the Canadian flag turned into a failed attempt at drawing a maple leaf that spanned nearly the entirety of r/place's existence. Canada's flag quickly became the target of memes as their leaf was never quite in shape. This led to constant vandalism of the flag. At one point, the flag was changed to yellow and the leaf changed to a banana. Canada managed to gain a little progress on their leaf, however the canvas ended before it could be fully completed.",
      paragraph2 = ""
    )

    addKeypoint(
      title = "Minecraft Loading Screen Animation",
      divname = "creeper",
      heatmapname = "creeperanimation",
      imglist = [["Minecraft_Timelapse.gif", "This is a timelapse of the Minecraft loading animation as it occured in r/place. Notice that despite its inperfections, the amount of detail behind this to coordinate the animation is huge because they would all have to place their pixels at the same time"]],
      paragraph1 = "This is where the Minecraft loading screen animation took place, which was one of the most upvoted posts on r/place. The animation was created by streamers NymN and Zoil. The streamers used their large audiences to coordinate the ",
      paragraph2 = "The idea of an animation being done on r/place"
    )

    addKeypoint(
      title = "The Void",
      divname = "void",
      heatmapname = "voidmap",
      imglist = [["Void_Timelapse.gif", "This is a timelapse of one of the biggest examples of the void, the large phenomenon of r/place. Notice the eventual creation of the face, which is clearly shown in the heatmap as an area of high activity."],
      ["Void_Consume.gif", "Void consume all."]],
      paragraph1 = "'The Void' refers to several distorted images and art present nearly at all times of r/place's existence, especially as many griefers would try their best to destroy art around the canvas. In addition, The Void, in its final moments, was a large area of black pixels consuming art wherever it spread. After the main void was destroyed by The First Hand, it moved up TotalBiscuit's hair and reformed right before the canvas ended. Created by The Swarm.",
      paragraph2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Mattis enim ut tellus elementum sagittis vitae et. Integer malesuada nunc vel risus commodo viverra maecenas accumsan lacus. Leo vel fringilla est ullamcorper eget. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Sed blandit libero volutpat sed cras ornare arcu dui. Lacus laoreet non curabitur gravida arcu ac tortor. Risus quis varius quam quisque id diam vel quam elementum. Duis at consectetur lorem donec massa sapien faucibus et. Sed odio morbi quis commodo odio aenean sed. Egestas egestas fringilla phasellus faucibus scelerisque. Ante in nibh mauris cursus mattis. Sed blandit libero volutpat sed cras."
    )



    function csvToArray(csv) {
      rows = csv.split("\n");
      return rows.map(function (row) {
        return row.split(",");
      });
    };

    const requestData = async () => {

      let tileData2017 = await d3.csv("data/2017_time_data.csv");
      tileData2017.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      let tileData2022 = await d3.csv("data/2022_time_data.csv");
      tileData2022.forEach(d => {
        d['count'] = parseInt(d['count']);
        d['min_from_zero'] = parseInt(d['min_from_zero']);
      })

      // let tileDataCanada = await d3.csv("data/cases/canada_time_cleaned.csv");
      // tileDataCanada.forEach(d => {
      //   d['count'] = parseInt(d['count']);
      //   d['min_from_zero'] = parseInt(d['min_from_zero']);
      // })

      tileschartmultiple(tileData2017, tileData2022, 'expo1', color_17, color_22, 2017, 2022);
      tileschart(tileData2017, 'expo2', color_17, 2017);
      tileschart(tileData2022, 'expo3', color_22, 2022);

      // tileschart(tileDataCanada, 'casecanada', color_22, 2022);


      let userData2017 = await d3.csv("data/2017_user_data.csv");
      histogram(userData2017, 'expo4', color_17);

      let userData2022 = await d3.csv("data/2022_user_data.csv");
      histogram(userData2022, 'expo5', color_22);

      barCompare(userData2017, userData2022, "expo7");

      const canadianflagData33 = await d3.text("data/canada_norm_updates_33.csv");
      const canadianflagData66 = await d3.text("data/canada_norm_updates_66.csv");
      const canadianflagData100 = await d3.text("data/canada_norm_updates_100.csv");
      const canadaDataArr = [csvToArray(canadianflagData33), csvToArray(canadianflagData66), csvToArray(canadianflagData100)]
      heatmapOverTime(canadaDataArr, 'canadianflag', 10);

      const minecraftData33 = await d3.text("data/minecraft_norm_updates_33.csv");
      const minecraftData66 = await d3.text("data/minecraft_norm_updates_66.csv");
      const minecraftData100 = await d3.text("data/minecraft_norm_updates_100.csv");
      const minecraftDataArr = [csvToArray(minecraftData33), csvToArray(minecraftData66), csvToArray(minecraftData100)]
      heatmapOverTime(minecraftDataArr, 'creeperanimation', 10);

      const voidData33 = await d3.text("data/void_norm_updates_33.csv");
      const voidData66 = await d3.text("data/void_norm_updates_66.csv");
      const voidData100 = await d3.text("data/void_norm_updates_100.csv");
      const voidDataArr = [csvToArray(voidData33), csvToArray(voidData66), csvToArray(voidData100)]
      heatmapOverTime(voidDataArr, 'voidmap', 3);

      hoverOnCircle();

    }


    // hover-over interaction adapted from example on https://greensock.com/forums/topic/24620-svg-image-magny-glass-effect/
    function hoverOnCircle() {
      var svgElement1 = document.getElementById("#canadianflagsvg");
      var maskedElement1 = document.querySelector('#mask-circle1');
      //  console.log(svgElement);
      var circleFeedback1 = document.querySelector('#circle-shadow1');
      var svgPoint1 = svgElement1.createSVGPoint();

      var svgElement2 = document.getElementById("#creeperanimationsvg");
      var maskedElement2 = document.querySelector('#mask-circle2');
      //  console.log(svgElement);
      var circleFeedback2 = document.querySelector('#circle-shadow2');
      var svgPoint2 = svgElement2.createSVGPoint();

      var svgElement3 = document.getElementById("#voidmapsvg");
      var maskedElement3 = document.querySelector('#mask-circle3');
      //  console.log(svgElement);
      var circleFeedback3 = document.querySelector('#circle-shadow3');
      var svgPoint3 = svgElement3.createSVGPoint();

      function cursorPoint1(e, svg) {
        svgPoint1.x = e.clientX;
        svgPoint1.y = e.clientY;
        return svgPoint1.matrixTransform(svg.getScreenCTM().inverse());
      }

      function update1(svgCoords) {
        maskedElement1.setAttribute('cx', svgCoords.x);
        maskedElement1.setAttribute('cy', svgCoords.y);
        circleFeedback1.setAttribute('cx', svgCoords.x);
        circleFeedback1.setAttribute('cy', svgCoords.y);
      }

      window.addEventListener('mousemove', function (e) {
        update1(cursorPoint1(e, svgElement1));
        update2(cursorPoint2(e, svgElement2));
        update3(cursorPoint3(e, svgElement3));
      }, false);

      document.addEventListener('touchmove', function (e) {
        e.preventDefault();
        var touch = e.targetTouches[0];
        if (touch) {
          update1(cursorPoint1(touch, svgElement1));
          update2(cursorPoint2(e, svgElement2));
          update3(cursorPoint3(e, svgElement3));
        }
      }, false);


      function cursorPoint2(e, svg) {
        svgPoint2.x = e.clientX;
        svgPoint2.y = e.clientY;
        return svgPoint2.matrixTransform(svg.getScreenCTM().inverse());
      }

      function update2(svgCoords) {
        maskedElement2.setAttribute('cx', svgCoords.x);
        maskedElement2.setAttribute('cy', svgCoords.y);
        circleFeedback2.setAttribute('cx', svgCoords.x);
        circleFeedback2.setAttribute('cy', svgCoords.y);
      }

      function cursorPoint3(e, svg) {
        svgPoint3.x = e.clientX;
        svgPoint3.y = e.clientY;
        return svgPoint3.matrixTransform(svg.getScreenCTM().inverse());
      }

      function update3(svgCoords) {
        maskedElement3.setAttribute('cx', svgCoords.x);
        maskedElement3.setAttribute('cy', svgCoords.y);
        circleFeedback3.setAttribute('cx', svgCoords.x);
        circleFeedback3.setAttribute('cy', svgCoords.y);
      }

      


    };  

    // for the dynamic styling on the anchor nav sidebar--
    // this must stay at the bottom of the script to work
    const sections = document.querySelectorAll("div[class='case']");
    window.addEventListener("scroll", navHighlighter); // event listener for scroll

    requestData();
  </script>
  <script type="text/javascript">

    var svgElement = document.querySelector('svg');
    var maskedElement = document.querySelector('#mask-circle');
    var circleFeedback = document.querySelector('#circle-shadow');
    var svgPoint = svgElement.createSVGPoint();

    function cursorPoint(e, svg) {
      svgPoint.x = e.clientX;
      svgPoint.y = e.clientY;
      return svgPoint.matrixTransform(svg.getScreenCTM().inverse());
    }

    function update(svgCoords) {
      maskedElement.setAttribute('cx', svgCoords.x);
      maskedElement.setAttribute('cy', svgCoords.y);
      circleFeedback.setAttribute('cx', svgCoords.x);
      circleFeedback.setAttribute('cy', svgCoords.y);
    }

    window.addEventListener('mousemove', function (e) {
      update(cursorPoint(e, svgElement));
    }, false);

    document.addEventListener('touchmove', function (e) {
      e.preventDefault();
      var touch = e.targetTouches[0];
      if (touch) {
        update(cursorPoint(touch, svgElement));
      }
    }, false);


  </script>
</body>

</html>
